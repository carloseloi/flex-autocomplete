<?xml version="1.0" encoding="utf-8"?>
<mx:Canvas 
	xmlns:mx="http://www.adobe.com/2006/mxml"
	clipContent="false" 
	borderStyle="inset"
	height="{ toolBar.height + 5 }"
	initialize="init()"
	xmlns:components="com.hillelcoren.components.*" 
	xmlns:classes="com.hillelcoren.components.choosers.classes.*">
	
	<mx:Metadata>
		[Event("COMBO_ITEM_SELECTED")]		
	</mx:Metadata>
		
	<mx:Script>
		<![CDATA[
			import mx.controls.Text;
			import mx.controls.TextArea;
			import com.hillelcoren.utils.KeyboardUtil;
			import com.hillelcoren.components.choosers.interfaces.iComboItem;
			import mx.core.UITextField;
			import com.hillelcoren.components.PromptTextInput;
			import mx.utils.ObjectUtil;
			import mx.effects.easing.Back;
			import mx.utils.StringUtil;
			import com.hillelcoren.utils.StringUtils;
			import mx.controls.TextInput;
			import mx.managers.CursorManager;
			import mx.events.ListEvent;
			import mx.events.CollectionEvent;
			import mx.events.FlexEvent;
			import mx.managers.PopUpManager;
			import mx.core.UIComponent;
			import mx.core.Application;
			import mx.collections.ArrayCollection;
			import mx.controls.List;
			
			private var _searchStr:String;
			private var _dropDown:List;
			
			[Bindable]
			private var _dataProvider:ArrayCollection;
			private var _dataProviderChanged:Boolean;
			
			private var _filterFunction:Function;
			private var _labelFunction:Function;
			private var _dropDownLabelFunction:Function;
			private var _isEqualFunction:Function;	
			
			private var _isMultiSelect:Boolean;
			private var _isMultiSelectChanged:Boolean;
			
			private var _prompt:String;
			private var _promptChanged:Boolean;
			
			private var _enableClearIcon:Boolean;
			private var _enableClearIconChanged:Boolean;
			
			private var _selectedItems:ArrayCollection;
			private var _selectedItem:Object;
			
			private static const ROW_COUNT:uint = 6; 
			
			public static const COMBO_ITEM_SELECTED:String = "COMBO_ITEM_SELECTED"; 
			
			private function init():void
			{
				addEventListener( KeyboardEvent.KEY_DOWN, handleKeyDown );
			}
			
			override protected function commitProperties():void
			{
				super.commitProperties();
			
				if (_dataProviderChanged)
				{
					_dataProviderChanged = false;
					
					if (_dropDown)
					{
						_dropDown.dataProvider = _dataProvider;
					}
				}
				
				if (_isMultiSelectChanged)
				{
					_isMultiSelectChanged = false;
					
					updateComoText();
				}				
			}
			
			private function createDropDown():void
			{
				_dropDown = new List();
				_dropDown.rowCount		= ROW_COUNT;
				_dropDown.focusEnabled 	= false;
				_dropDown.dataProvider 	= _dataProvider;
				_dropDown.itemRenderer  = new ClassFactory( ChooserItemRenderer );
				_dropDown.labelFunction = _dropDownLabelFunction;
				_dropDown.addEventListener( ListEvent.ITEM_CLICK, handleItemClick );
				
				systemManager.addEventListener( MouseEvent.CLICK, handleMouseClick );
			}
			
			private function handleKeyDown( event:KeyboardEvent ):void
			{
				if (isDropDownVisible())
				{
					if (event.keyCode == Keyboard.DOWN)
					{
						_dropDown.selectedIndex++;
						_dropDown.scrollToIndex( _dropDown.selectedIndex );
						
						//promptTextInput.setTextSelected( false );
					}
					else if (event.keyCode == Keyboard.UP)
					{
						if (_dropDown.selectedIndex > 0)
						{
							_dropDown.selectedIndex--;
							_dropDown.scrollToIndex( _dropDown.selectedIndex );
						}
						
						//promptTextInput.setTextSelected( false );			
					}
					else if (event.keyCode == Keyboard.ESCAPE || event.keyCode == Keyboard.TAB)
					{
						hideDropDown();
					}
					// charCode 44 is a comma
					//else if (event.keyCode == Keyboard.ENTER || event.charCode == 44)
					else if (event.keyCode == Keyboard.ENTER)
					{
						setSelectedItem( _dropDown.selectedItem );						
					}
				}
				else
				{
					var comp:iComboItem = determineFocus();
					var comboItem:iComboItem;
					var index:int = toolBar.getChildIndex( comp as DisplayObject );
				
					if (event.keyCode == Keyboard.BACKSPACE)
					{
						if (_selectedItems.length == 0)
						{
							return;
						}
						
						if (!comp.isCursorAtBeginning())
						{
							return;
						}
						
						var focused:DisplayObject = focusManager.getFocus() as DisplayObject;
						
						if (focused is SelectedItem)
						{
							var selectedItem:SelectedItem = focused as SelectedItem;
							index = _selectedItems.getItemIndex( selectedItem.item );
							_selectedItems.removeItemAt( index );
							
							toolBar.removeChild( focused );
							updateComoText();
							
							comboItem = toolBar.getChildAt( index ) as iComboItem;
							comboItem.setTextFocus();							
						}
						else
						{
							if (index == 0)
							{
								return;
							}
							
							var prevItem:UIComponent = toolBar.getChildAt( index - 1 ) as UIComponent;
							prevItem.setFocus();
							
							if (prevItem is ComboTextInput)
							{
								ComboTextInput( prevItem ).setSelectionEnd();
							}
						}						
					}
					else if (event.keyCode == Keyboard.LEFT)
					{
						if (index > 0)
						{
							if (!comp.isCursorAtBeginning())
							{
								return;
							}
						
							comboItem = toolBar.getChildAt( index - 1 ) as iComboItem;
							comboItem.setTextFocus();
							
							if (comboItem is ComboTextInput)
							{
								ComboTextInput( comboItem ).setSelectionEnd();
							}
						}					
					}
					else if (event.keyCode == Keyboard.RIGHT)
					{
						if (index < toolBar.numChildren - 1)
						{
							if (!comp.isCursorAtEnd())
							{
								return;
							}							
							
							comboItem = toolBar.getChildAt( index + 1 ) as iComboItem;
							comboItem.setTextFocus();
						}
					}
					else if (event.keyCode == Keyboard.ENTER)
					{
						if (comp.isEditable())
						{
							setSelectedItem( comp.text, false, true );
						}
					}
				}
				
				// check for the comma key	
				if (event.charCode == 44)
				{
					var input:iComboItem = determineFocus();
					
					if (input.isEditable())
					{
						setSelectedItem( input.text, false, true );
					}								
				}
			}
						
			private function determineFocus():iComboItem
			{
				var comp:UIComponent = focusManager.getFocus() as UIComponent;
				
				for each (var item:iComboItem in toolBar.getChildren())
				{
					if (item.contains( comp ))
					{
						return item;
					}	
				}
				
				return null;
			}
			
			private function cleanStr( value:String ):String
			{
				value = StringUtil.trim( value );
					
				if (value.charAt( value.length - 1 ) == ",")
				{
					value = value.substr( 0, value.length - 1 );
				}
					
				return value;
			}
			
			public function setSelectedItem( value:Object, isSilent:Boolean = false, isNew:Boolean = false ):void
			{
				if (isNew)
				{
					value = cleanStr( value as String );
				}
				
				//dispatchEvent( new Event( COMBO_ITEM_SELECTED ) );
				if (_selectedItems.getItemIndex( value ) == -1 && value)
				{
					_selectedItems.addItem( value );
					
					textInput.width = 0;
					
					if (isNew)
					{
						var comboTextInput:ComboTextInput = new ComboTextInput();
						comboTextInput.text = value + ",";
						comboTextInput.width = measureText( value as String ).width + 10;
						comboTextInput.height = textInput.height;
						comboTextInput.item = value;
						comboTextInput.addEventListener( Event.CHANGE, handleComboItemChange );
						toolBar.addChildAt( comboTextInput, toolBar.numChildren - 1 );												
					}
					else
					{
						var selectedItem:SelectedItem = new SelectedItem();
						selectedItem.label = _labelFunction( value );
						selectedItem.item = value;
						selectedItem.addEventListener( FlexEvent.CREATION_COMPLETE, sizeTextInput );
						toolBar.addChildAt( selectedItem, toolBar.numChildren - 1 );
					}					
				}
				// this means the user entered a comma after a value which has already
				// been added, in this case we just need to readd the comma
				else if (_selectedItems.getItemIndex( value ) >= 0 && isNew)
				{
					var index:int = _selectedItems.getItemIndex( value );
					var input:ComboTextInput = toolBar.getChildAt( index ) as ComboTextInput;
					
					input.text = cleanStr( input.text ) + ",";													
				}
				
				updateComoText();
				textInput.setFocus();
				
				if (!isSilent)
				{
					dispatchEvent( new Event( COMBO_ITEM_SELECTED ) );
				}
				
				if (isDropDownVisible())
				{
					// we're using a callLater here as a workaround for not being
					// able to prevent the enter keyboard event from bubbling. Delaying
					// the selection gives the UI a chance to check if the enter key
					// was clicked while the drop down was visible 
					callLater( hideDropDown );
				}					
			}
			
			private function handleComboItemChange( event:Event ):void
			{
				var comboTextInput:ComboTextInput = event.currentTarget as ComboTextInput;
				var index:int = _selectedItems.getItemIndex( comboTextInput.item );
				
				var text:String = comboTextInput.text;
				text = StringUtil.trim( text );
				
				if (text.length > 0)
				{
					_selectedItems.setItemAt( text, index );
					comboTextInput.item = text;
				}
				else
				{
					_selectedItems.removeItemAt( index );
					toolBar.removeChild( comboTextInput );
					
					var comboItem:iComboItem = toolBar.getChildAt( index ) as iComboItem;
					comboItem.setTextFocus();
				}
			}
			
			public function updateComoText():void
			{
				callLater( _updateComoText );
			}
			
			private function _updateComoText():void
			{
				textInput.text = "";
				textInput.validateNow();
				
				sizeTextInput();				
			}
			
			private function sizeTextInput( event:Event = null ):void
			{
				if (_selectedItems.length > 0)
				{
					var comboItem:UIComponent = toolBar.getChildAt( toolBar.numChildren - 2 ) as UIComponent;
					textInput.width = toolBar.width - (comboItem.x + comboItem.width);  
				}				
				else
				{
					textInput.width = toolBar.width;
				}	
			}
			
			private function handleItemClick( event:ListEvent ):void
			{
				setSelectedItem( _dropDown.selectedItem );
			}
			
			/**
			 * If the list is visible and we click somewhere else
			 * we're going to close it
			 */
			private function handleMouseClick( event:MouseEvent ):void
			{
				if (!isDropDownVisible())
				{
					return;
				}
				
				if (!_dropDown.hitTestPoint( event.stageX, event.stageY ))
				{
					hideDropDown();
				}
			}
			
			public function handleChange( event:Event ):void
			{
				dispatchEvent( event );
				
				if (!_dataProvider)
				{
					return;
				}
				
				var textInput:PromptTextInput = event.currentTarget as PromptTextInput;
				_searchStr = textInput.text;
				
				//var start:Date = new Date();
				filterData();
				//var end:Date = new Date();
				//trace(">> search took: " + (end.getTime() - start.getTime()) + " msecs" );
				
				if (_dataProvider.length == 0)
				{
					hideDropDown();
					return;
				}
				else if (isPerfectMatch())
				{
					return;
				}
				
				if (isDropDownVisible())
				{
					if (_searchStr.length == 0)
					{
						hideDropDown();
					}
				}
				else
				{
					if (_searchStr.length > 0 && _dataProvider.length > 0)
					{
						showDropDown();	
					}
				}
				
				if (isDropDownVisible())
				{
					callLater( positionDropDown );
					callLater( highlightFirstItem );
					_dropDown.rowCount = (_dataProvider.length < ROW_COUNT ? _dataProvider.length : ROW_COUNT);
				}
			}
			
			private function highlightFirstItem():void
			{
				_dropDown.selectedIndex = 0;
			}
			
			private function isPerfectMatch():Boolean
			{
				if (_dataProvider.length == 1)
				{
					var item:Object = _dataProvider.getItemAt( 0 );
					
					if (_isEqualFunction != null)
					{
						if (_isEqualFunction( item, searchText ))
						{
							setSelectedItem( item );
							return true;
						}
					}
					else
					{
						var str:String = _labelFunction( item );
						
						if (str.toLowerCase() == searchText.toLowerCase())
						{
							setSelectedItem( item );
							return true;
						}
					}
				}
				
				return false;
			}
			
			private function handleChangeOnceSelected():void
			{
				/*
				var prettyName:String 	= _labelFunction( _selectedItem );
				var searchStr:String	= promptTextInput.text;	
				var newSearchStr:String;
				
				// user entered more text (ie Bob => Bobd)
				if (searchStr.substr( 0, prettyName.length ) == prettyName && searchStr.length > prettyName.length)
				{
					newSearchStr = searchStr.substring( prettyName.length, searchStr.length ); 
				}
				// user hit the backspace key (ie Bob => Bo)
				else if (searchStr == prettyName.substr( 0, searchStr.length ))
				{
					newSearchStr = "";
				}
				// user highlighted the text the pressed a key
				else if (searchStr.length == 1)
				{
					newSearchStr = searchStr;
				}
				
				setSelectedItem( null );
				
				promptTextInput.text = newSearchStr;
				promptTextInput.setTextSelected( false );
				*/
			}
			
			public function get searchText():String
			{
				return textInput.text;
			}
			
			public function filterData():void
			{
				_dataProvider.filterFunction = filterFunctionWrapper;
				_dataProvider.refresh();
			}
			
			/*
			private function handleFocusIn():void
			{
				if (isItemSelected)
				{
					promptTextInput.setTextSelected( false );
				}
				else
				{
					promptTextInput.setTextSelected( true );					
				}
			}
			*/
			
			private function showDropDown():void
			{
				if (_dropDown == null)
				{
					createDropDown();
				}
				
				_dropDown.width = width;
				_dropDown.owner = this;
				_dropDown.scrollToIndex(0);
				
				PopUpManager.addPopUp( _dropDown, this );				
			}
			
			public function positionDropDown():void
			{
				if (!isDropDownVisible())
				{
					return;
				}
				
				var localPoint:Point = new Point( 0, height );
				var globalPoint:Point = localToGlobal( localPoint );
								
				_dropDown.x = globalPoint.x;
				
				// check if it will fit below the textInput 
				if (Application.application.height - globalPoint.y > dropDown.height)	
				{
					_dropDown.y = globalPoint.y;
				}
				else
				{
					_dropDown.y = globalPoint.y - height - dropDown.height;
				}				
			}
			
			/*
			private function handleFocusOut( event:FocusEvent ):void
			{			
				if (isDropDownVisible())
				{
					if (!event.relatedObject || !_dropDown.contains( event.relatedObject ))
					{
						hideDropDown();
					}
				}
			}
			*/
			
			private function hideDropDown():void
			{
				PopUpManager.removePopUp( _dropDown );
			}
			
			public function get dropDown():List
			{
				return _dropDown;
			}
			
			public function set labelFunction( value:Function ):void
			{
				_labelFunction = value;
			}
			
			public function set dropDownLabelFunction( value:Function ):void
			{
				_dropDownLabelFunction = value;
			}
			
			public function set filterFunction( value:Function ):void
			{
				_filterFunction = value;
			}
			
			public function set selectedItems( value:ArrayCollection ):void
			{
				_selectedItems = value;
			}
			
			public function set isMultiSelect( value:Boolean ):void
			{
				 _isMultiSelect = value;
				 _isMultiSelectChanged = true;
				 
				 invalidateProperties();
			}
			
			private function filterFunctionWrapper( item:Object ):Boolean
			{
				return _filterFunction( item, _searchStr );
			}
			
			public function set isEqualFunction( value:Function ):void
			{
				_isEqualFunction = value;
			}
			
			public function set dataProvider( value:ArrayCollection ):void
			{
				_dataProvider = value;
				_dataProviderChanged = true;
				
				invalidateProperties();
			}
			
			public function get dataProvider():ArrayCollection
			{
				return _dataProvider;
			}
			
			public function set text( value:String ):void
			{
				//promptTextInput.text = value;
			}
			
			public function get text():String
			{
				return "";
				//return promptTextInput.text;	
			}
			
			public function set htmlText( value:String ):void
			{
				//promptTextInput.htmlText = value;
			}
			
			public function get htmlText():String
			{
				return "";
				//return promptTextInput.htmlText;	
			}
			
			public function isDropDownVisible():Boolean
			{
				return _dropDown && _dropDown.parent;
			}
			
			public function set prompt( value:String ):void
			{
				_prompt = value;
				_promptChanged = true;
				
				invalidateProperties();
			}
			
			public function set enableClearIcon( value:Boolean ):void
			{
				_enableClearIcon = value;
				_enableClearIconChanged = true;
				
				invalidateProperties();
			}
			
			public function get selectedItem():Object
			{
				return _selectedItem;
			}
			
			public function get isItemSelected():Boolean
			{
				return _selectedItems.length > 0;
			}
			
			override public function setFocus():void
			{
				textInput.setFocus();
			}
			
		]]>
	</mx:Script>
	
	<mx:ToolBar id="toolBar" horizontalGap="0" verticalGap="0" width="100%" paddingTop="0" x="2" y="3">
		<components:PromptTextInput id="textInput" width="{ toolBar.width }" change="handleChange(event)" borderStyle="solid" move="sizeTextInput()"/>		
	</mx:ToolBar>
	 
</mx:Canvas>