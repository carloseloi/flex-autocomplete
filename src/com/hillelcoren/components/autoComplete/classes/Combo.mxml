<?xml version="1.0" encoding="utf-8"?>
<mx:Canvas 
	xmlns:mx="http://www.adobe.com/2006/mxml"
	clipContent="false" 
	borderStyle="inset" borderThickness="1"
	height="{ flowBox.height + 5 }" width="100%"
	initialize="init()" backgroundColor="#FFFFFF"
	verticalScrollPolicy="off" horizontalScrollPolicy="off"
	xmlns:components="com.hillelcoren.components.*" 
	xmlns:classes="com.hillelcoren.components.autoComplete.classes.*">
	
	<mx:Metadata>
		[Event("change")]		
	</mx:Metadata>
		
	<mx:Script>
		<![CDATA[
			import com.hillelcoren.components.AutoComplete;
			import com.hillelcoren.components.autoComplete.interfaces.iComboItem;
			import mx.controls.Text;
			import mx.controls.TextArea;
			import com.hillelcoren.utils.KeyboardUtil;
			import mx.core.UITextField;
			import com.hillelcoren.components.PromptTextInput;
			import mx.utils.ObjectUtil;
			import mx.effects.easing.Back;
			import mx.utils.StringUtil;
			import com.hillelcoren.utils.StringUtils;
			import mx.controls.TextInput;
			import mx.managers.CursorManager;
			import mx.events.ListEvent;
			import mx.events.CollectionEvent;
			import mx.events.FlexEvent;
			import mx.managers.PopUpManager;
			import mx.core.UIComponent;
			import mx.core.Application;
			import mx.collections.ArrayCollection;
			import mx.controls.List;
			
			private var _searchStr:String;
			private var _dropDown:List;
			
			[Bindable]
			private var _dataProvider:ArrayCollection;
			private var _dataProviderChanged:Boolean;
			
			private var _filterFunction:Function;
			private var _labelFunction:Function;
			private var _dropDownLabelFunction:Function;
			private var _dropDownItemRenderer:IFactory;
			private var _isEqualFunction:Function;	
			private var _onBackspace:String;
			
			private var _isMultiSelect:Boolean;
			private var _isMultiSelectChanged:Boolean;
			private var _multiSelectLayout:String;
			
			private var _isStrict:Boolean;
					
			private var _prompt:String;
			private var _promptChanged:Boolean;
			
			private var _enableClearIcon:Boolean;
			private var _enableClearIconChanged:Boolean;
			
			private var _enableRemoveIcon:Boolean;
			private var _enableRemoveIconChanged:Boolean;
			
			private var _selectedItems:ArrayCollection;
			private var _selectedItem:Object;
			
			private var _style:String = AutoComplete.STYLE_OSX;
			private var _styleChanged:Boolean;
			
			private static const ROW_COUNT:uint = 6; 
			
			private function init():void
			{
				addEventListener( KeyboardEvent.KEY_DOWN, handleKeyDown );
			}
			
			override protected function commitProperties():void
			{
				super.commitProperties();
			
				if (_dataProviderChanged)
				{
					_dataProviderChanged = false;
					
					if (_dropDown)
					{
						_dropDown.dataProvider = _dataProvider;
					}
				}
				
				if (_isMultiSelectChanged)
				{
					_isMultiSelectChanged = false;
					
					clearFlowBox();
					updateComoText();
				}				
				
				if (_enableClearIconChanged)
				{
					_enableClearIconChanged = false;
					textInput.enableClearIcon = _enableClearIcon;
				}
				
				if (_styleChanged)
				{
					_styleChanged = false;
					flowBox.style = _style;
				}
				
				if (_enableRemoveIconChanged)
				{
					_enableRemoveIconChanged = false;
					flowBox.enableRemoveIcon = _enableRemoveIcon;
				}
			}
			
			private function createDropDown():void
			{
				_dropDown = new List();
				_dropDown.rowCount		= ROW_COUNT;
				_dropDown.focusEnabled 	= false;
				_dropDown.dataProvider 	= _dataProvider;
				_dropDown.labelFunction = _dropDownLabelFunction;
				_dropDown.itemRenderer  = _dropDownItemRenderer ? _dropDownItemRenderer : new ClassFactory( DropDownItemRenderer );
				_dropDown.addEventListener( ListEvent.ITEM_CLICK, handleItemClick );

				systemManager.addEventListener( MouseEvent.CLICK, handleMouseClick );
			}
			
			private function handleKeyDown( event:KeyboardEvent ):void
			{
				if (isDropDownVisible())
				{
					if (event.keyCode == Keyboard.DOWN)
					{
						_dropDown.selectedIndex++;
						_dropDown.scrollToIndex( _dropDown.selectedIndex );
						
						textInput.setCursorPosition( textInput.selectionBeginIndex );
						//promptTextInput.setTextSelected( false );
					}
					else if (event.keyCode == Keyboard.UP)
					{
						if (_dropDown.selectedIndex > 0)
						{
							_dropDown.selectedIndex--;
							_dropDown.scrollToIndex( _dropDown.selectedIndex );
						}
						
						textInput.setCursorPosition( textInput.selectionBeginIndex );
						//promptTextInput.setTextSelected( false );			
					}
					else if (event.keyCode == Keyboard.ESCAPE || event.keyCode == Keyboard.TAB)
					{
						hideDropDown();
					}
					// charCode 44 is a comma
					//else if (event.keyCode == Keyboard.ENTER || event.charCode == 44)
					else if (event.keyCode == Keyboard.ENTER || event.keyCode == Keyboard.TAB)
					{
						setSelectedItem( _dropDown.selectedItem );	
						return;											
					}
				}
				else
				{
					var comp:iComboItem = determineFocus();
					var comboItem:iComboItem;
					var index:int = flowBox.getChildIndex( comp as DisplayObject );
				
					if (event.keyCode == Keyboard.BACKSPACE)
					{
						if (_selectedItems.length == 0)
						{
							return;
						}
						
						if (!comp.isCursorAtBeginning())
						{
							return;
						}
						
						var focused:DisplayObject = focusManager.getFocus() as DisplayObject;
						
						if (focused is SelectedItem)
						{
							removeItem( focused as UIComponent );
						}
						else
						{
							if (index == 0)
							{
								return;
							}
							
							var prevItem:UIComponent = flowBox.getChildAt( index - 1 ) as UIComponent;
							prevItem.setFocus();
							
							if (prevItem is ComboTextInput)
							{
								ComboTextInput( prevItem ).setSelectionEnd();								
							}							
							else if (_onBackspace == AutoComplete.BACKSPACE_REMOVE)
							{
								removeItem( prevItem );	
							}							
						}						
					}
					else if (event.keyCode == Keyboard.UP)
					{
						var pos:Point = flowBox.getItemPosition( comp );
						pos.y--;
							
						var item:iComboItem = flowBox.getItemByPosition( pos );
						
						if (item)
						{
							item.setTextFocus();
						}
					}
					else if (event.keyCode == Keyboard.DOWN)
					{
						var pos:Point = flowBox.getItemPosition( comp );
						pos.y++;
						
						var item:iComboItem = flowBox.getItemByPosition( pos );
						
						if (item)
						{
							item.setTextFocus();
						}
					}
					else if (event.keyCode == Keyboard.LEFT)
					{
						if (index > 0)
						{
							if (!comp.isCursorAtBeginning())
							{
								return;
							}
						
							comboItem = flowBox.getChildAt( index - 1 ) as iComboItem;
							comboItem.setTextFocus();
							
							if (comboItem is ComboTextInput)
							{
								ComboTextInput( comboItem ).setSelectionEnd();
							}
						}					
					}
					else if (event.keyCode == Keyboard.RIGHT)
					{
						if (index < flowBox.numChildren - 1)
						{
							if (!comp.isCursorAtEnd())
							{
								return;
							}							
							
							comboItem = flowBox.getChildAt( index + 1 ) as iComboItem;
							comboItem.setTextFocus();
						}
					}
					else if (event.keyCode == Keyboard.ENTER || event.charCode == 44)
					{
						if (!_isStrict && comp.isEditable())
						{
							setSelectedItem( comp.text, false, true );
							return;
						}
					}
				}
			}
			
			private function removeItem( item:UIComponent ):void
			{
				if (item is SelectedItem)
				{
					var selectedItem:SelectedItem = item as SelectedItem;
					var index:int = _selectedItems.getItemIndex( selectedItem.item );
					
					if (index == -1)
					{
						return;
					}
					
					_selectedItems.removeItemAt( index );
				}
				
				var compIndex:int = flowBox.getChildIndex( item as UIComponent );
				flowBox.removeChild( item as UIComponent );
				updateComoText();
				
				var comboItem:iComboItem = flowBox.getChildAt( compIndex ) as iComboItem;
				comboItem.setTextFocus();
				
				var event:Event = new Event( Event.CHANGE );
				dispatchEvent( event );	
			}			
			
			private function determineFocus():iComboItem
			{
				var comp:UIComponent = focusManager.getFocus() as UIComponent;
				
				for each (var item:iComboItem in flowBox.getChildren())
				{
					if (item.contains( comp ))
					{
						return item;
					}	
				}
				
				return null;
			}
			
			private function cleanStr( value:String ):String
			{
				value = StringUtil.trim( value );
				
				while (value.length > 0 && value.charAt(0) == ",")
				{
					value = value.substring( 1, value.length );
				}
				
				while (value.length > 0 && value.charAt( value.length - 1 ) == ",")
				{
					value = value.substring( 0, value.length - 1);
				}
				
				return value;
			}
			
			public function setSelectedItem( value:Object, isSilent:Boolean = false, isNew:Boolean = false ):void
			{
				var validItem:Boolean = true;
				
				if (isNew)
				{
					value = cleanStr( value as String );
				}
				
				if (_selectedItems.getItemIndex( value ) == -1 && value)
				{
					if (_multiSelectLayout == AutoComplete.LAYOUT_HORIZONTAL)
					{ 
						_selectedItems.addItem( value );
					}
					else
					{
						_selectedItems.addItemAt( value, 0 );
					}
					
					textInput.width = 0;
					
					if (_isMultiSelect && _multiSelectLayout == AutoComplete.LAYOUT_VERTICAL)
					{
						// do nothing
					}
					else if (isNew)
					{
						var comboTextInput:ComboTextInput = new ComboTextInput();
						comboTextInput.text = value + ",";
						comboTextInput.width = measureText( value as String ).width + 10;
						comboTextInput.height = textInput.height;
						comboTextInput.item = value;
						comboTextInput.addEventListener( Event.CHANGE, handleComboItemChange, false, 0, true );
						flowBox.addChildAt( comboTextInput, flowBox.numChildren - 1 );									
					}
					else
					{
						var selectedItem:SelectedItem = new SelectedItem();
						selectedItem.text = _labelFunction( value );
						selectedItem.item = value;
						selectedItem.style = _style;
						selectedItem.height = textInput.height;
						selectedItem.enableRemoveIcon = _enableRemoveIcon;
						selectedItem.addEventListener( FlexEvent.CREATION_COMPLETE, sizeTextInput, false, 0, true );
						selectedItem.addEventListener( FlexEvent.REMOVE, handleItemRemove, false, 0, true );
						flowBox.addChildAt( selectedItem, flowBox.numChildren - 1 );
					}					
				}
				// this means the user entered a comma after a value which has already
				// been added, in this case we just need to readd the comma
				else if (_selectedItems.getItemIndex( value ) >= 0 && isNew)
				{
					var index:int = _selectedItems.getItemIndex( value );
					var input:ComboTextInput = flowBox.getChildAt( index ) as ComboTextInput;
					
					input.text = cleanStr( input.text ) + ",";													
				}
				else
				{
					validItem = false;
				}
				
				updateComoText();
				
				if (validItem)
				{
					textInput.setFocus();
				
					if (!isSilent)
					{
						dispatchEvent( new Event( Event.CHANGE ) );
					}
				}
				
				if (isDropDownVisible())
				{
					// we're using a callLater here as a workaround for not being
					// able to prevent the enter keyboard event from bubbling. Delaying
					// the selection gives the UI a chance to check if the enter key
					// was clicked while the drop down was visible 
					callLater( hideDropDown );
				}
			}
			
			private function handleItemRemove( event:Event ):void
			{
				removeItem( event.currentTarget as UIComponent );
			}
			
			private function handleComboItemChange( event:Event ):void
			{
				var comboTextInput:ComboTextInput = event.currentTarget as ComboTextInput;
				var index:int = _selectedItems.getItemIndex( comboTextInput.item );
				
				var text:String = comboTextInput.text;
				text = cleanStr( text );
				
				if (text.length > 0)
				{
					// check if the user added text after the commma
					var indexComma:int = text.indexOf( "," );
					
					if (indexComma > 0)
					{
						var addStr:String = text.substring( indexComma + 1, text.length );
						text = text.substr( 0, indexComma );
						comboTextInput.text = text + ",";
						textInput.text = addStr;
						textInput.setFocus();
						textInput.setTextSelected( false );
					}
					
					_selectedItems.setItemAt( text, index );
					comboTextInput.item = text;				
				}
				else
				{
					_selectedItems.removeItemAt( index );
					flowBox.removeChild( comboTextInput );
					
					var comboItem:iComboItem = flowBox.getChildAt( index ) as iComboItem;
					comboItem.setTextFocus();
				}
			}
			
			public function updateComoText():void
			{
				callLater( _updateComoText );
			}
			
			private function _updateComoText():void
			{
				textInput.text = null;
				textInput.validateNow();
				
				sizeTextInput();				
			}
			
			private function sizeTextInput( event:Event = null ):void
			{
				if (_selectedItems.length == 0 &&
					(!_isMultiSelect || _multiSelectLayout == AutoComplete.LAYOUT_VERTICAL))
				{
					textInput.width = flowBox.width;
					return;
				}				
				
				var width:int = -1;
				
				if (textInput.textInput.horizontalScrollPosition > 0)
				{
					width = flowBox.width;
				}
				else if (_selectedItems.length > 0)
				{ 
					var comboItem:UIComponent = flowBox.getChildAt( flowBox.numChildren - 2 ) as UIComponent;
					var availableWidth:int = flowBox.width - (comboItem.x + comboItem.width);
					
					// if the last combo item width is 0 it means it has been 
					// created but not yet added (so we don't yet know how wide to
					// make the text input)
					if (comboItem.width == 0)
					{
						width = 0;						
					}
					else if (availableWidth > textInput.measureText( textInput.text ).width + 30)
					{
						width = availableWidth;
					}
					else
					{
						width = flowBox.width;
					}
				}				
				else if (flowBox.width > 0)
				{
					width = flowBox.width;
				}
				
				if (width >= 0)
				{
					/*
					if (width && width < flowBox.width * .2)
					{
						width = flowBox.width;
					}
					*/
					
					textInput.width = width;
				}
			}
			
			private function handleItemClick( event:ListEvent ):void
			{
				setSelectedItem( _dropDown.selectedItem );
			}
			
			/**
			 * If the list is visible and we click somewhere else
			 * we're going to close it
			 */
			private function handleMouseClick( event:MouseEvent ):void
			{
				if (!isDropDownVisible())
				{
					return;
				}
				
				if (!_dropDown.hitTestPoint( event.stageX, event.stageY ))
				{
					hideDropDown();
				}
			}
			
			public function clearFlowBox():void
			{
				while (flowBox.numChildren > 1)
				{
					flowBox.removeChildAt( 0 );
				}
			}
			
			public function handleChange( event:Event ):void
			{
				if (selectedItem && !_isMultiSelect)
				{
					_selectedItems.removeAll();
					clearFlowBox();		
				}
				
				sizeTextInput();
				
				if (!_dataProvider)
				{
					return;
				}
				
				var textInput:PromptTextInput = event.currentTarget as PromptTextInput;
				_searchStr = textInput.text;
				
				//var start:Date = new Date();
				filterData();
				//var end:Date = new Date();
				//trace(">> search took: " + (end.getTime() - start.getTime()) + " msecs" );
				
				if (_dataProvider.length == 0)
				{
					hideDropDown();
					return;
				}
				else if (isPerfectMatch())
				{
					return;
				}
				
				if (isDropDownVisible())
				{
					if (_searchStr.length == 0)
					{
						hideDropDown();
					}
				}
				else
				{
					if (_searchStr.length > 0 && _dataProvider.length > 0)
					{
						showDropDown();	
					}
				}
				
				if (isDropDownVisible())
				{
					callLater( positionDropDown );
					callLater( highlightFirstItem );
					_dropDown.rowCount = (_dataProvider.length < ROW_COUNT ? _dataProvider.length : ROW_COUNT);
				}
			}
			
			private function handleMove():void
			{
				sizeTextInput();
			}
			
			private function highlightFirstItem():void
			{
				_dropDown.selectedIndex = 0;
			}
			
			private function isPerfectMatch():Boolean
			{
				if (_dataProvider.length == 1)
				{
					var item:Object = _dataProvider.getItemAt( 0 );
					
					if (_isEqualFunction != null)
					{
						if (_isEqualFunction( item, searchText ))
						{
							setSelectedItem( item );
							return true;
						}
					}
					else
					{
						var str:String = _labelFunction( item );
						
						if (str.toLowerCase() == searchText.toLowerCase())
						{
							setSelectedItem( item );
							return true;
						}
					}
				}
				
				return false;
			}
						
			public function get searchText():String
			{
				return textInput.text;
			}
			
			public function filterData():void
			{
				_dataProvider.filterFunction = filterFunctionWrapper;
				_dataProvider.refresh();
			}
			
			/*
			private function handleFocusIn():void
			{
				if (isItemSelected)
				{
					promptTextInput.setTextSelected( false );
				}
				else
				{
					promptTextInput.setTextSelected( true );					
				}
			}
			*/
			
			private function showDropDown():void
			{
				if (_dropDown == null)
				{
					createDropDown();
				}
				
				_dropDown.width = width;
				_dropDown.owner = this;
				_dropDown.scrollToIndex(0);
				
				PopUpManager.addPopUp( _dropDown, this );				
			}
			
			public function positionDropDown():void
			{
				if (!isDropDownVisible())
				{
					return;
				}
				
				var localPoint:Point = new Point( 0, height );
				var globalPoint:Point = localToGlobal( localPoint );
								
				_dropDown.x = globalPoint.x;
				
				// check if it will fit below the textInput 
				if (Application.application.height - globalPoint.y > dropDown.height)	
				{
					_dropDown.y = globalPoint.y;
				}
				else
				{
					_dropDown.y = globalPoint.y - height - dropDown.height;
				}				
			}
			
			/*
			private function handleFocusOut( event:FocusEvent ):void
			{			
				if (isDropDownVisible())
				{
					if (!event.relatedObject || !_dropDown.contains( event.relatedObject ))
					{
						hideDropDown();
					}
				}
			}
			*/
			
			private function hideDropDown():void
			{
				PopUpManager.removePopUp( _dropDown );
			}
			
			public function get dropDown():List
			{
				return _dropDown;
			}
			
			public function set labelFunction( value:Function ):void
			{
				_labelFunction = value;
			}
			
			public function set dropDownLabelFunction( value:Function ):void
			{
				_dropDownLabelFunction = value;
			}
			
			public function set dropDownItemRenderer( value:IFactory ):void
			{
				_dropDownItemRenderer = value;
			}
			
			public function set filterFunction( value:Function ):void
			{
				_filterFunction = value;
			}
			
			public function set isStrict( value:Boolean ):void
			{
				_isStrict = value;
			}
			
			public function set selectedItems( value:ArrayCollection ):void
			{
				_selectedItems = value;
			}
			
			public function set isMultiSelect( value:Boolean ):void
			{
				 _isMultiSelect = value;
				 _isMultiSelectChanged = true;
				 
				 invalidateProperties();
			}
			
			private function filterFunctionWrapper( item:Object ):Boolean
			{
				return _filterFunction( item, _searchStr );
			}
			
			public function set isEqualFunction( value:Function ):void
			{
				_isEqualFunction = value;
			}
			
			public function set style( value:String ):void
			{
				_style = value;
				_styleChanged = true;
				
				invalidateProperties();
			}
			
			public function set dataProvider( value:ArrayCollection ):void
			{
				_dataProvider = value;
				_dataProviderChanged = true;
				
				invalidateProperties();
			}
			
			public function get dataProvider():ArrayCollection
			{
				return _dataProvider;
			}
			
			public function set text( value:String ):void
			{
				textInput.text = value;
			}
			
			public function set htmlText( value:String ):void
			{
				//promptTextInput.htmlText = value;
			}
			
			public function get htmlText():String
			{
				return "";
				//return promptTextInput.htmlText;	
			}
			
			public function isDropDownVisible():Boolean
			{
				return _dropDown && _dropDown.parent;
			}
			
			public function set prompt( value:String ):void
			{
				_prompt = value;
				_promptChanged = true;
				
				invalidateProperties();
			}
			
			public function set enableClearIcon( value:Boolean ):void
			{
				_enableClearIcon = value;
				_enableClearIconChanged = true;
				
				invalidateProperties();
			}
			
			public function set enableRemoveIcon( value:Boolean ):void
			{
				_enableRemoveIcon = value;
				_enableRemoveIconChanged = true;
				
				invalidateProperties();
			}
			
			public function get selectedItem():Object
			{
				return isItemSelected ? _selectedItems.getItemAt(0) : null;
			}
			
			public function get isItemSelected():Boolean
			{
				return _selectedItems.length > 0;
			}
			
			override public function setFocus():void
			{
				textInput.setFocus();
			}
			
			public function set onBackspace( value:String ):void
			{
				_onBackspace = value;
			}
			
			public function set multiSelectLayout( value:String ):void
			{
				_multiSelectLayout = value;
			}
			
		]]>
	</mx:Script>
	
	<classes:FlowBox id="flowBox" horizontalGap="0" verticalGap="0" width="100%" height="100%" x="2" y="3" >
		<components:PromptTextInput id="textInput" width="{ flowBox.width }" paddingTop="0" enableClearIcon="false"
			change="handleChange(event)" move="handleMove()"/>		
	</classes:FlowBox>
	 
</mx:Canvas>